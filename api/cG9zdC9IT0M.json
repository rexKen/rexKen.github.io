{"title":"React高阶组件","date":"2019-04-25T10:50:23.000Z","slug":"HOC","tags":["React"],"updated":"2019-04-25T10:51:56.000Z","content":"<h1 id=\"React-高阶组件\"><a href=\"#React-高阶组件\" class=\"headerlink\" title=\"React 高阶组件\"></a>React 高阶组件</h1><p>​    高阶组件的概念应该是来源于JavaScript的高阶函数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">高阶函数就是接受函数作为输入或者输出的函数</span><br></pre></td></tr></table></figure>\n<p>​    由此定义可以知道，高阶组件就是一个接受组件作为输入并且返回组件的函数。高阶组件的实现方式有以下两种:</p>\n<ol>\n<li>属性代理（Props Proxy)</li>\n<li>反向继承</li>\n</ol>\n<h2 id=\"属性代理\"><a href=\"#属性代理\" class=\"headerlink\" title=\"属性代理\"></a>属性代理</h2><p>​    属性代理的意思是通过包裹原来的组件来操作props(组件作为参数传入):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'React'</span>;</span><br><span class=\"line\"><span class=\"comment\">//高阶组件定义</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> HOC = <span class=\"function\">(<span class=\"params\">WrappedComponent</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WrapperComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newProps = &#123;</span><br><span class=\"line\">                name: <span class=\"string\">'我是新增属性'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            storeRef(ref) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.ref = ref;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &lt;WrappedComponent</span><br><span class=\"line\">                &#123;...this.props&#125;</span><br><span class=\"line\">                &#123;...newProps&#125;</span><br><span class=\"line\">        \t\tref = &#123;::this.storeRef&#125;</span><br><span class=\"line\">            /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//普通的组件</span><br><span class=\"line\">class WrappedComponent extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        //....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//高阶组件使用</span><br><span class=\"line\">export default HOC(WrappedComponent)</span><br></pre></td></tr></table></figure>\n<p>​    由上面可以i看出，高阶组件通过包裹传入的组件可以获取到被包裹组件的props的控制。可以对组件进行为所欲为的控制（前提是你能承担操作后的风险），我们可以在WrappedComponent组件中增加一个新的name属性。也可以轻松的拿到被包裹组件实例引用的ref，简直是为所欲为。</p>\n<h2 id=\"反向继承\"><a href=\"#反向继承\" class=\"headerlink\" title=\"反向继承\"></a>反向继承</h2><p>​    反向继承是指返回的组件去继承之前的组件(这里都用WrappedComponent代指)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> HOC = <span class=\"function\">(<span class=\"params\">WrappedComponent</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.render();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>​    我们可以看见返回的组件确实都继承自WrappedComponent,那么所有的调用将是反向调用的(例如:<code>super.render()</code>)，这也就是为什么叫做反向继承。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//例子来源于《深入React技术栈》</span><br><span class=\"line\"></span><br><span class=\"line\">const HOC = (WrappedComponent) =&gt;</span><br><span class=\"line\">    class extends WrappedComponent &#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            const elementsTree = super.render();</span><br><span class=\"line\">            let newProps = &#123;&#125;;</span><br><span class=\"line\">            if (elementsTree &amp;&amp; elementsTree.type === &apos;input&apos;) &#123;</span><br><span class=\"line\">                newProps = &#123;value: &apos;may the force be with you&apos;&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            const props = Object.assign(&#123;&#125;, elementsTree.props, newProps);</span><br><span class=\"line\">            const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children);</span><br><span class=\"line\">            return newElementsTree;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class WrappedComponent extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return(</span><br><span class=\"line\">            &lt;input value=&#123;&apos;Hello World&apos;&#125; /&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default HOC(WrappedComponent)</span><br><span class=\"line\">//实际显示的效果是input的值为&quot;may the force be with you&quot;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n","prev":{"title":"Generator 函数","slug":"Generator"},"next":{"title":"如何理解函数式编程","slug":"functionalPrograming"},"link":"https://rexken.github.io/post/HOC/","toc":[{"title":"React 高阶组件","id":"React-高阶组件","index":"1","children":[{"title":"属性代理","id":"属性代理","index":"1.1"},{"title":"反向继承","id":"反向继承","index":"1.2"}]}]}