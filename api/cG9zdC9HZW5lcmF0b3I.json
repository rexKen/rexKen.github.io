{"title":"Generator 函数","date":"2019-04-29T07:39:23.000Z","slug":"Generator","tags":["ES6"],"updated":"2019-04-29T07:39:25.000Z","content":"<h1 id=\"Generator-函数语法\"><a href=\"#Generator-函数语法\" class=\"headerlink\" title=\"Generator 函数语法\"></a>Generator 函数语法</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>\n<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>\n<p>Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">helloWorldGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'ending'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>\n<p>由上面的代码可以知道，定义的helloWorldGenerator函数内部有俩个yield表达式（hello和world),即改函数有三个状态: hello, world 和 return 语句（结束执行）</p>\n<p>Generator函数调用方法和普通函数一样，也是函数后面家一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p>\n<p>下一步，必须调用遍历器对象的next 方法，使得指针指向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或者return 语句）为止。换言之，Generator函数是分别段执行的， yield表达式是暂停执行的标志，而next方法可以恢复执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: 'hello', done: false &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: 'world', done: false &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: 'ending', done: true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<p>上面代码一共调用了四次<code>next</code>方法。</p>\n<p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>\n<p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>\n<p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p>\n<p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p>\n<h2 id=\"yield-表达式\"><a href=\"#yield-表达式\" class=\"headerlink\" title=\"yield 表达式\"></a>yield 表达式</h2><p>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</p>\n<p>遍历器对象的<code>next</code>方法的运行逻辑如下。</p>\n<ul>\n<li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</li>\n<li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</li>\n<li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li>\n<li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</li>\n</ul>\n<p>需要注意的是，<code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p>\n<p><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）<code>return</code>语句，但是可以执行多次（或者说多个）<code>yield</code>表达式。正常函数只能返回一个值，因为只能执行一次<code>return</code>；Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）</p>\n<p>另外需要注意，<code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p>\n<h2 id=\"next-方法的参数\"><a href=\"#next-方法的参数\" class=\"headerlink\" title=\"next 方法的参数\"></a>next 方法的参数</h2><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; <span class=\"literal\">true</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reset = <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(reset) &#123; i = <span class=\"number\">-1</span>; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f();</span><br><span class=\"line\"></span><br><span class=\"line\">g.next() <span class=\"comment\">// &#123; value: 0, done: false &#125;</span></span><br><span class=\"line\">g.next() <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.next(<span class=\"literal\">true</span>) <span class=\"comment\">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure>\n<p>上面代码先定义了一个可以无限运行的 Generator 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。</p>\n<p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过<code>next</code>方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>\n<h2 id=\"for…of循环\"><a href=\"#for…of循环\" class=\"headerlink\" title=\"for…of循环\"></a>for…of循环</h2><p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* foo() &#123;</span><br><span class=\"line\">  yield 1;</span><br><span class=\"line\">  yield 2;</span><br><span class=\"line\">  yield 3;</span><br><span class=\"line\">  yield 4;</span><br><span class=\"line\">  yield 5;</span><br><span class=\"line\">  return 6;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let v of foo()) &#123;</span><br><span class=\"line\">  console.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 1 2 3 4 5</span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator-prototype-throw\"><a href=\"#Generator-prototype-throw\" class=\"headerlink\" title=\"Generator.prototype.throw()\"></a>Generator.prototype.throw()</h2><p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'内部捕获'</span>, e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = g();</span><br><span class=\"line\">i.next();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  i.throw(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">  i.throw(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'外部捕获'</span>, e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 内部捕获 a</span></span><br><span class=\"line\"><span class=\"comment\">// 外部捕获 b</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，遍历器对象<code>i</code>连续抛出两个错误。第一个错误被 Generator 函数体内的<code>catch</code>语句捕获。<code>i</code>第二次抛出错误，由于 Generator 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的<code>catch</code>语句捕获。</p>\n<p><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例。</p>\n<p>更多关于Generator函数的知识，<a href=\"http://es6.ruanyifeng.com/#docs/generator\" target=\"_blank\" rel=\"noopener\">查看阮一峰的文档</a></p>\n","prev":{"title":"async函数的使用","slug":"async"},"next":{"title":"React高阶组件","slug":"HOC"},"link":"https://rexken.github.io/post/Generator/","toc":[{"title":"Generator 函数语法","id":"Generator-函数语法","index":"1","children":[{"title":"基本概念","id":"基本概念","index":"1.1"},{"title":"yield 表达式","id":"yield-表达式","index":"1.2"},{"title":"next 方法的参数","id":"next-方法的参数","index":"1.3"},{"title":"for…of循环","id":"for…of循环","index":"1.4"},{"title":"Generator.prototype.throw()","id":"Generator-prototype-throw","index":"1.5"}]}]}